#!/usr/bin/python3

#
# Yet Another DDNS updater
#
# License: Apache 2.0
#
# Copyright(c) 2020 Gary Buhrmaster <gary.buhrmaster@gmail.com>
#

import socket
import argparse
import sys
import ssl
import urllib.request
import urllib.error
import urllib.parse
import random
import ipaddress

# Not everything is available in Python
if not hasattr(socket, "IPV6_ADDR_PREFERENCES"):
    socket.IPV6_ADDR_PREFERENCES = 72
if not hasattr(socket, "IPV6_PREFER_SRC_TMP"):
    socket.IPV6_PREFER_SRC_TMP = 1
if not hasattr(socket, "IPV6_PREFER_SRC_PUBLIC"):
    socket.IPV6_PREFER_SRC_PUBLIC = 2

#
# Wrappers to force urlopen to use specified transport
#
def urlopenIPv6(*args, **kwargs):
    original_socket_getaddrinfo = socket.getaddrinfo
    def getaddrinfoIPv6(host, port, family=0, type=0, proto=0, flags=0):
        return original_socket_getaddrinfo(host, port, family=socket.AF_INET6, type=type, proto=proto, flags=flags)
    socket.getaddrinfo = getaddrinfoIPv6
    r = None
    try:
        r = urllib.request.urlopen(*args, **kwargs)
    except:
        raise
    finally:
        socket.getaddrinfo = original_socket_getaddrinfo
    return r

def urlopenIPv4(*args, **kwargs):
    original_socket_getaddrinfo = socket.getaddrinfo
    def getaddrinfoIPv4(host, port, family=0, type=0, proto=0, flags=0):
        return original_socket_getaddrinfo(host, port, family=socket.AF_INET, type=type, proto=proto, flags=flags)
    socket.getaddrinfo = getaddrinfoIPv4
    r = None
    try:
        r = urllib.request.urlopen(*args, **kwargs)
    except:
        raise
    finally:
        socket.getaddrinfo = original_socket_getaddrinfo
    return r

def urlopenANY(*args, **kwargs):
    return urllib.request.urlopen(*args, **kwargs)

#
# Obtain the IP address for the hostname via DNS
#
def getDNSIPv4(hostname):
    try:
        ipaddr = ipaddress.ip_address(socket.getaddrinfo(hostname, None, socket.AF_INET)[0][4][0])
        if ipaddr.version == 4:
            if args.debug:
                print('DNS IPv4 address is {}'.format(ipaddr.compressed))
            return ipaddr.compressed
        if args.debug:
            print('DNS IPv4 address was not valid')
        return None 
    except (OSError, ValueError, TypeError, IndexError):
        if args.debug:
            print('DNS IPv4 address exception')
        return None

def getDNSIPv6(hostname):
    try:
        ipaddr = ipaddress.ip_address(socket.getaddrinfo(hostname, None, socket.AF_INET6)[0][4][0])
        if ipaddr.version == 6:
            if args.debug:
                print('DNS IPv6 address is {}'.format(ipaddr.compressed))
            return ipaddr.compressed
        if args.debug:
            print('DNS IPv6 address was not valid')
        return None
    except (OSError, ValueError, TypeError, IndexError):
        if args.debug:
            print('DNS IPv6 address exception')
        return None

#
# Determine local ip address
#
def getLocalIPv4():
    if args.debug:
        print('determining local IPv4 address by opening a local socket')
    ip = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # doesn't even have to be reachable
        # so we use the documentation IPv4
        s.connect(('192.0.2.1', 1))
        ip = s.getsockname()[0]
        try:
            if ipaddress.ip_address(ip).version != 4:
                if args.debug:
                    print('  returned ip adddress {} is not a valid IPv4 address'.format(ip))
                    ip = None
            else:
                ip = ipaddress.ip_address(ip).compressed
        except ValueError:
            if args.debug:
                print('  returned ip address {} is not a valid IP address'.format(ip))
                ip = None
    except (OSError, ValueError, TypeError, IndexError):
        if args.debug:
            print('  exception on socket operation')
        ip = None
    finally:
        s.close()
    if args.debug:
        print('  determined local IPv4 address to be {}'.format(ip))
    return ip

def getLocalIPv6():
    if args.debug:
        print('determining local IPv6 address by opening a local socket')
    ip = None
    try:
        s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)

        if sys.platform.startswith('linux'):
            # try to request the global ipv6 address
            try:
                s.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_ADDR_PREFERENCES, socket.IPV6_PREFER_SRC_PUBLIC)
            except OSError:
                if args.debug:
                    print('  exception trying to set socket option')

        # doesn't even have to be reachable
        # so we use the documentation IPv6
        s.connect(('2001:DB8::1', 1))
        ip = s.getsockname()[0]
        try:
            if ipaddress.ip_address(ip).version != 6:
                if args.debug:
                    print('  returned ip adddress {} is not a valid IPv6 address'.format(ip))
                    ip = None
            else:
                ip = ipaddress.ip_address(ip).compressed
        except ValueError:
            if args.debug:
                print('  returned ip address {} is not a valid IP address'.format(ip))
                ip = None
    except (OSError, ValueError, TypeError, IndexError):
        if args.debug:
            print('  exception on socket operation')
        ip = None
    finally:
        s.close()
    if args.debug:
        print('  determined local IPv6 address to be {}'.format(ip))
    return ip

#
# Determine external ip address from external sources
#
def getRemoteExternalIPv4():
    externalProviders = [
                          'https://domains.google.com/checkip',
                          'https://ipv4.nsupdate.info/myip',
                          'https://api.ipify.org',
                          'https://ipv4bot.whatismyipaddress.com',
                          'https://ipv4.icanhazip.com'
                        ]
    random.shuffle(externalProviders)
    for provider in externalProviders:
        if args.debug:
            print('trying to determine external IPv4 address from {}'.format(provider))
        try:
            request = urllib.request.Request(provider, method='GET')
            request.add_header = ('User-Agent', 'Python-urllib/3')
            response = urlopenIPv4(request, timeout=20)
            if (response.status < 200) or (response.status > 299):
                if args.debug:
                    print('  failed to get response')
                continue
            ip = response.read().decode("utf-8").strip()
            if ip:
                try:
                    if ipaddress.ip_address(ip).version != 4:
                        if args.debug:
                            print('  returned ip adddress {} is not a valid IPv4 address'.format(ip))
                        continue
                except ValueError:
                    if args.debug:
                        print('  returned ip address {} is not a valid IP address'.format(ip))
                    continue
                if args.debug:
                    print('  determined ip address is {}'.format(ip))
                return ip
            if args.debug:
                print('  no ip address returned')
        except (IOError, ValueError, OSError, urllib.error.URLError, urllib.error.HTTPError):
            if args.debug:
                print('  exception occurred')
    return None

def getRemoteExternalIPv6():
    externalProviders = [
                          'https://domains.google.com/checkip',
                          'https://ipv6.nsupdate.info/myip',
                          'https://api6.ipify.org',
                          'https://ipv6bot.whatismyipaddress.com',
                          'https://ipv6.icanhazip.com'
                        ]
    random.shuffle(externalProviders)
    for provider in externalProviders:
        if args.debug:
            print('trying to determine external IPv6 address from {}'.format(provider))
        try:
            request = urllib.request.Request(provider, method='GET')
            request.add_header = ('User-Agent', 'Python-urllib/3')
            response = urlopenIPv6(request, timeout=20)
            if (response.status < 200) or (response.status > 299):
                if args.debug:
                    print('  failed to get response')
                continue
            ip = response.read().decode("utf-8").strip()
            if ip:
                try:
                    if ipaddress.ip_address(ip).version != 6:
                        if args.debug:
                            print('  returned ip adddress {} is not a valid IPv6 address'.format(ip))
                        continue
                except ValueError:
                    if args.debug:
                        print('  returned ip address {} is not a valid IP address'.format(ip))
                    continue
                if args.debug:
                    print('  determined ip address is {}'.format(ip))
                return ip
            if args.debug:
                print('  no ip address returned')
        except (IOError, ValueError, OSError, urllib.error.URLError, urllib.error.HTTPError):
            if args.debug:
                print('  exception occurred')
    return None




if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--api',
                        action='store', type=str, required=True,
                        choices=['dyn', 'google', 'he'],
                        help='The API type (currently only he supported)')
    parser.add_argument('--dyn-api-url',
                        action='store', type=str, required=False, dest='apiurl',
                        help='The url to use if the api type is dyn') 
    parser.add_argument('--hostname', '--fqdn',
                        action='store', type=str, required=True,
                        help='The hostname to update')
    parser.add_argument('--username', '--credentials', '--api-key-id', 
                        action='store', type=str, required=True,
                        help='The username for the update')
    parser.add_argument('--password', '--credentials-password', '--api-key-secret',
                        action='store', type=str, required=True,
                        help='The password/apikey for the update')
    ipgroup = parser.add_mutually_exclusive_group(required=False)
    ipgroup.add_argument('--use-ddns-provider-ip', '--use-ddns-provider-IP', '--use-ddns-ip', '--use-ddns-IP',
                        action='store_true', default=False, dest='providerip',
                        help='Use the external IP address as determined by the dns provider')
    ipgroup.add_argument('--use-localip', '--use-localIP', '--use-local-ip', '--use-local-IP',
                        action='store_true', default=False, dest='localip',
                        help='Use the local determined IP rather than the default IP')
    parser.add_argument('--ipv4', '--IPv4', '--4',
                        action='store_true', default=False,
                        help='Update the IPv4 address')
    parser.add_argument('--ipv6', '--IPv6', '--6',
                        action='store_true', default=False,
                        help='Update the IPv6 address')
    parser.add_argument('--ipaddress', '--IPAddress', '--ip-address', '--IP-address',
                        type=str,
                        help='The IP address to set')
    parser.add_argument('--force',
                        action='store_true', default=False,
                        help='Force the update even when there appears to be no change')
    parser.add_argument('--verbose',
                        action='store_true', default=False,
                        help='Verbose logging')
    parser.add_argument('--debug',
                        action='store_true', default=False,
                        help='Debug logging')
    parser.add_argument('--quiet',
                        action='store_true', default=False,
                        help='Quiet logging')

    args = parser.parse_args()

    ReturnCode = 0

    UpdateIPv4 = 1
    UpdateIPv6 = 1
    UpdateIP = 0

    IPv4 = None
    IPv6 = None
    IP = None

    IPv4DNS = getDNSIPv4(args.hostname)
    IPv6DNS = getDNSIPv6(args.hostname)

    if args.ipv4:
        UpdateIPv4 += 1
        UpdateIPv6 -= 1

    if args.ipv6:
        UpdateIPv4 -= 1
        UpdateIPv6 += 1

    if args.ipaddress:
        UpdateIP = 1
        UpdateIPv4 = 0
        UpdateIPv6 = 0

    #
    # Google has a "feature", in that it only supports either
    # an IPv4 or and IPv6 address, not both.  So we need to
    # remove the IPv6 address update request if both are requested
    #
    if UpdateIPv4 and UpdateIPv6 and (args.api == 'google'):
        print('Google dynamic DNS only supports either an IPv4 or an IPv6 address, not both.')
        print('The IPv6 address update request has been removed from the update request.')
        UpdateIPv6 = 0

    if UpdateIPv4:
        if args.providerip:
            if args.verbose or args.debug:
                print('IPv4 address will be determined by dynamic dns provider')
        elif args.localip:
            IPv4 = getLocalIPv4()
            if IPv4 is None:
                UpdateIPv4 = 0
                print('Unable to determine local IPv4 address')
                ReturnCode = 1
            else:
                if args.verbose or args.debug:
                    print('Local IPv4 address determined to be: {}'.format(IPv4))
                if IPv4 == IPv4DNS:
                    if args.force:
                        if args.verbose or args.debug:
                            print('Local IPv4 address is the same as DNS, but update will be forced')
                    else:
                        if args.verbose or args.debug:
                            print('Local IPv4 address is the same as DNS, no update will be performed')
                        UpdateIPv4 = 0
                else:
                    if args.verbose or args.debug:
                        print('Local IPv4 address is different than DNS, will be updated')
        else:
            IPv4 = getRemoteExternalIPv4()
            if IPv4 is None:
                UpdateIPv4 = 0
                print('Unable to determine external IPv4 address')
                ReturnCode = 1
            else:
                if args.verbose or args.debug:
                    print('External IPv4 address determined to be: {}'.format(IPv4))
                if IPv4 == IPv4DNS:
                    if args.force:
                        if args.verbose or args.debug:
                            print('External IPv4 address is the same as DNS, but update will be forced')
                    else:
                        if args.verbose or args.debug:
                            print('External IPv4 address is the same as DNS, no update will be performed')
                        UpdateIPv4 = 0
                else:
                    if args.verbose or args.debug:
                        print('External IPv4 address is different than DNS, will be updated')

    if UpdateIPv6:
        if args.providerip:
            if args.verbose or args.debug:
                print('IPv6 address will be determined by dynamic dns provider')
        elif args.localip:
            IPv6 = getLocalIPv6()
            if IPv6 is None:
                UpdateIPv6 = 0
                print('Unable to determine local IPv6 address')
                ReturnCode = 1
            else:
                if args.verbose or args.debug:
                    print('Local IPv6 address determined to be: {}'.format(IPv6))
                if IPv6 == IPv6DNS:
                    if args.force:
                        if args.verbose or args.debug:
                            print('Local IPv6 address is the same as DNS, but update will be forced')
                    else:
                        if args.verbose or args.debug:
                            print('Local IPv6 address is the same as DNS, no update will be performed')
                        UpdateIPv6 = 0
                else:
                    if args.verbose or args.debug:
                        print('Local IPv6 address is different than DNS, will be updated')
        else:
            IPv6 = getRemoteExternalIPv6()
            if IPv6 is None:
                UpdateIPv6 = 0
                print('Unable to determine remote IPv6 address')
                ReturnCode = 1
            else:
                if args.verbose or args.debug:
                    print('External IPv6 address determined to be: {}'.format(IPv6))
                if IPv6 == IPv6DNS:
                    if args.force:
                        if args.verbose or args.debug:
                            print('External IPv6 address is the same as DNS, but update will be forced')
                    else:
                        if args.verbose or args.debug:
                            print('External IPv6 address is the same as DNS, no update will be performed')
                        UpdateIPv6 = 0
                else:
                    if args.verbose or args.debug:
                        print('External IPv6 address is different than DNS, will be updated')

    if UpdateIP:
        try:
            IP = ipaddress.ip_address(args.ipaddress).compressed
        except ValueError:
            print('Specified IP address {} is invalid'.format(args.ipaddress))
            UpdateIP = 0
            IP = None
            ReturnCode = 1
        else:
            if args.verbose or args.debug:
                print('Specified IP address is: {} ',format(IP))
            if IP in (IPv6DNS, IPv4DNS):
                if args.force:
                    if args.verbose or args.debug:
                        print('Specified IP address is the same as DNS, but update will be forced')
                else:
                    if args.verbose or args.debug:
                        print('Specified IP address is the same as DNS, no update will be performed')
                    UpdateIP = 0
            else:
                if args.verbose or args.debug:
                    print('Specified IP address is different than DNS, will be updated')

    #
    # Scenerios that the API providers must support
    #
    # * (single) ip address specified
    # * IPv4 and/or IPv6 address derived (either via local or external)
    # * IPv4 and/or IPv6 address will be auto determined by provider
    #

    #
    # The "defacto" standard ddns update method (dyn was an early popular ddns
    # provider, and many/most providers have followed their update method)
    #

    def dynUpdate(url=None, username=None, password=None, hostname=None, myip=None, transport='ANY', method='GET', extradata={}):
        if url is None:
            print('The dynamic ddns update URL was not specified')
            ReturnCode = 1
            return
        if username is None:
            print('The dynamic ddns username was not specified')
            ReturnCode = 1
            return
        if password is None:
            print('The dynamic ddns password was not specified')
            ReturnCode = 1
            return
        if hostname is None:
            print('The dynamic ddns hostname was not specified')
            ReturnCode = 1
            return
        if method not in ('GET', 'POST'):
            print('The dynamic ddns method is not GET or POST')
            ReturnCode = 1
            return

        if args.debug:
            print('dynUpdate called with:')
            print('  url:          {}'.format(url))
            print('  username:     {}'.format(username))
            print('  password:     {}'.format(password))
            print('  hostname:     {}'.format(hostname))
            print('  myip:         {}'.format(myip))
            print('  transport:    {}'.format(transport))
            print('  method:       {}'.format(method))
            print('  extradata:    {}'.format(extradata))

        querydata = {'hostname': hostname}
        if myip is not None:
            querydata['myip'] = myip
        querydata.update(extradata)

        data = urllib.parse.urlencode(querydata)
        headers = {'User-Agent': 'Python-urllib/3'}
        if method == 'GET':
            request = urllib.request.Request(url + '?' + data, headers=headers, method='GET')
        else:
            request = urllib.request.Request(url, data=data.encode('utf-8'), headers=headers, method='POST')

        # Install opener to support basic authentication
        passwordManager = urllib.request.HTTPPasswordMgrWithDefaultRealm()
        passwordManager.add_password(None, url, username, password)
        authHandler = urllib.request.HTTPBasicAuthHandler(passwordManager)
        opener = urllib.request.build_opener(authHandler)
        original_openerDirector = urllib.request.OpenerDirector
        urllib.request.install_opener(opener)

        # Use the required transport for the open
        try:
            if transport == 'IPv4':
                response = urlopenIPv4(request)
            elif transport == 'IPv6':
                response = urlopenIPv6(request)
            else:
                response = urlopenANY(request)
        except (IOError, ValueError, OSError, urllib.error.URLError, urllib.error.HTTPError) as e:
            print('exception occured when attempting update')
            if args.debug:
                print(e)
            ReturnCode = 1
            return
        except:
            raise
        finally:
            urllib.request.OpenerDirector = original_openerDirector

        # Handle response
        if (response.status < 200) or (response.status > 299):
            print('Update failed with response status {}'.format(response.status))
            ReturnCode = 1
            return
        else:
            txt = response.read().decode('utf-8')
            if txt.startswith(('good ')):
                if args.verbose or args.debug:
                    print('Update successful to IP address {}'.format(myip))
            elif txt.startswith(('nochg ')):
                if args.verbose or args.debug:
                    print('No update required to set IP address {}'.format(myip))
            else:
                print('Failed to set host {} IP address to {}'.format(hostname, myip))
                print(txt)
                ReturnCode = 1
                return
        return


    #
    # For the providers that support the dyn protocol
    # share the majority of code paths.
    #
    # For the dyn protocol, the transport type only
    # matters if the address will be auto-determined.
    #
    # Most of the time the response status will be 200
    # with the actual results in the text (good, nochg,
    # badauth, interval)
    #
    # While POST is arguably the correct protocol type,
    # dyn itself has deprecated it, and the other
    # providers also support GET, so we use GET
    #

    if args.api in ('dyn', 'google', 'he'):

        if args.api == 'dyn':

            # https://{user}:{updater client key}@members.dyndns.org/v3/update?hostname={hostname}&myip={IP Address}

            updateURL = 'https://members.dyndns.org/v3/update'

            if args.apiurl:
                updateURL = args.apiurl

        elif args.api == 'google':

            # https://username:password@domains.google.com/nic/update?hostname=subdomain.yourdomain.com&myip=1.2.3.4

            updateURL = 'https://domains.google.com/nic/update'

        elif args.api == 'he':

            # dynUpdate('https://dyn.dns.he.net/nic/update', username=args.hostname, password=args.password, hostname=args.hostname, myip=xxxx)

            updateURL = 'https://dyn.dns.he.net/nic/update'

        else:

            print('Internal error - supported api is unsupported')
            ReturnCode = 1
            UpdateIP = 0
            UpdateIPv4 = 0
            UpdateIPv6 = 0

        if UpdateIP:
            dynUpdate(url=updateURL, username=args.username, password=args.password, hostname=args.hostname, myip=IP)

        if UpdateIPv4:
            if IPv4:
                dynUpdate(url=updateURL, username=args.username, password=args.password, hostname=args.hostname, myip=IPv4)
            else:
                dynUpdate(url=updateURL, username=args.username, password=args.password, hostname=args.hostname, transport='IPv4')

        if UpdateIPv6:
            if IPv6:
                dynUpdate(url=updateURL, username=args.username, password=args.password, hostname=args.hostname, myip=IPv6)
            else:
                dynUpdate(url=updateURL, username=args.username, password=args.password, hostname=args.hostname, transport='IPv6')

    else:

        print('Unsupported API')
        ReturnCode = 1


    sys.exit(ReturnCode)
